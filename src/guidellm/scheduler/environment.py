"""
Scheduler environment abstractions for distributed and non-distributed execution.

This module provides environment abstractions that handle synchronization and
coordination for schedulers in both distributed and non-distributed
configurations. Environments manage the lifecycle of scheduler runs, from
parameter synchronization to error handling and cleanup.

Classes:
    Environment: Abstract base class defining the environment interface for
        scheduler coordination across single or multiple nodes.
    NonDistributedEnvironment: Concrete implementation for single-node execution
        with simplified synchronization semantics.
"""

import time
from abc import ABC, abstractmethod
from collections.abc import AsyncIterator, Iterable
from typing import (
    Generic,
    Optional,
)

from guidellm.config import settings
from guidellm.scheduler.constraints import CallableConstraint
from guidellm.scheduler.objects import (
    RequestT,
    RequestTimingsT,
    ResponseT,
    ScheduledRequestInfo,
    SchedulerState,
)
from guidellm.scheduler.strategy import SchedulingStrategy

__all__ = ["Environment", "NonDistributedEnvironment"]


class Environment(ABC, Generic[RequestT, ResponseT]):
    """
    Abstract base class for scheduler execution environments.

    This class defines the interface for coordinating scheduler execution across
    one or more nodes. Environments handle synchronization of parameters, timing,
    state updates, error propagation, and cleanup for scheduler runs.

    Type Parameters:
        RequestT: The type of requests being processed by the scheduler.
        ResponseT: The type of responses generated by request processing.
    """

    @abstractmethod
    async def sync_run_params(
        self,
        requests: Iterable[RequestT],
        strategy: SchedulingStrategy,
        constraints: dict[str, CallableConstraint],
    ) -> tuple[
        Iterable[RequestT],
        SchedulingStrategy,
        dict[str, CallableConstraint],
    ]:
        """
        Synchronize run parameters across all nodes and resolve local execution scope.

        This method coordinates the distribution of run parameters across all active
        nodes in the environment. For distributed environments, it handles parameter
        validation, node assignment, and workload partitioning. For non-distributed
        environments, it typically returns parameters unchanged.

        :param requests: Complete set of requests to be processed across all nodes.
        :param strategy: Scheduling strategy to be applied during execution.
        :param constraints: Runtime constraints to be enforced during execution.
        :return: Tuple of (local_requests, strategy, constraints) for this node.
        :raises Exception: If parameter synchronization fails or nodes are inconsistent.
        """
        ...

    @abstractmethod
    async def sync_run_start(self) -> float:
        """
        Coordinate global start time across all nodes for synchronized execution.

        This method ensures all nodes begin request processing at the same time,
        which is critical for accurate benchmarking and performance measurement.
        The returned timestamp represents when all nodes should start processing.

        :return: Unix timestamp when all nodes should begin request processing.
        :raises Exception: If startup synchronization fails across nodes.
        """
        ...

    @abstractmethod
    async def update_run_iteration(
        self,
        response: Optional[ResponseT],
        request: RequestT,
        request_info: ScheduledRequestInfo[RequestTimingsT],
    ):
        """
        Update environment state with completed request iteration.

        This method is called after each request is processed to update the
        environment's view of execution progress. For distributed environments,
        this enables state synchronization across nodes. For non-distributed
        environments, this is typically a no-op.

        :param response: Response generated for the request, if successful.
        :param request: The processed request.
        :param request_info: Metadata about request processing including timings.
        :raises Exception: If state update fails or indicates critical errors.
        """
        ...

    @abstractmethod
    async def sync_run_error(self, err: Exception):
        """
        Handle and propagate errors across all nodes in the environment.

        This method coordinates error handling when failures occur during execution.
        It ensures all nodes are notified of critical errors and can perform
        appropriate cleanup or shutdown procedures.

        :param err: The exception that occurred during execution.
        """
        ...

    @abstractmethod
    async def sync_run_end(
        self,
    ) -> AsyncIterator[
        tuple[
            ResponseT, RequestT, ScheduledRequestInfo[RequestTimingsT], SchedulerState
        ]
    ]:
        """
        Finalize execution and aggregate results from all nodes.

        This method handles cleanup, result synchronization, and error propagation
        at the end of a scheduler run. For distributed environments, it collects
        results from worker nodes. For all environments, it raises any errors
        that occurred during execution.

        :return: Iterator of (response, request, request_info, state) tuples from
            remote nodes in distributed environments, empty for non-distributed.
        :raises Exception: Any errors that occurred during the run.
        """
        ...


class NonDistributedEnvironment(Environment):
    """
    Environment implementation for single-node scheduler execution.

    This class provides a simplified environment for running schedulers on a single
    node without distributed coordination. It implements the Environment interface
    with minimal synchronization overhead, making it suitable for local testing,
    development, and single-machine benchmarking.

    Attributes:
        run_err: Stores any exception that occurs during execution for later raising.
    """

    def __init__(self):
        """Initialize the non-distributed environment with no stored errors."""
        self.run_err: Exception = None

    async def sync_run_params(
        self,
        requests: Iterable[RequestT],
        strategy: SchedulingStrategy,
        constraints: dict[str, CallableConstraint],
    ) -> tuple[Iterable[RequestT], SchedulingStrategy, dict[str, CallableConstraint]]:
        """
        Return parameters unchanged for single-node execution.

        :param requests: Iterable of requests to process.
        :param strategy: Scheduling strategy to be applied during execution.
        :param constraints: Runtime constraints to be enforced during execution.
        :return A tuple containing the original (requests, strategy, constraints).
        """
        return requests, strategy, constraints

    async def sync_run_start(self) -> float:
        """
        Return current time plus configuration delay for coordinated start.

        :return: Unix timestamp for when the run should start (current time + delay).
        """
        return time.time() + settings.scheduler_start_delay_non_distributed

    async def update_run_iteration(
        self,
        response: Optional[ResponseT],
        request: RequestT,
        request_info: ScheduledRequestInfo[RequestTimingsT],
    ):
        """
        No-op for single-node execution (no state synchronization needed).

        :param response: Response generated for the request, if successful and complete.
        :param request: The request that a processing update is being made for.
        :param request_info: Metadata about request processing including timings.
        """

    async def sync_run_error(self, err: Exception):
        """
        Store error for later propagation and raising during run finalization.

        :param err: The exception that occurred during execution.
        """
        self.run_err = err

    async def sync_run_end(
        self,
    ) -> AsyncIterator[
        tuple[
            ResponseT, RequestT, ScheduledRequestInfo[RequestTimingsT], SchedulerState
        ]
    ]:
        """
        Finalize single-node execution and propagate any stored errors.

        :return: An empty iterator since there are no remote nodes to
            yield results from.
        :raises Exception: Any error stored during execution via sync_run_error.
        """
        if self.run_err:
            raise self.run_err
